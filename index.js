// index.js
const { Telegraf, Markup } = require('telegraf');
const config = require('./config');
const commands = require('./commands');
const middlewares = require('./middlewares');
const { scanToken, getDexScreenerUrl, formatFindings } = require('./utils/tokenScanner');

const bot = new Telegraf(config.TELEGRAM_BOT_TOKEN);

// Middlewares
bot.use(middlewares.logMiddleware);

// Basic Commands
bot.command('start', commands.startCommand);
bot.command('help', commands.helpCommand);
bot.command('wallet', commands.walletCommand);
bot.command('scanner', commands.scannerCommand);

// Handle text messages (for address scanning and wallet import)
bot.on('text', async (ctx) => {
  const userId = ctx.from.id;
  const userState = commands.userStates.get(userId);

  if (userState && userState.action === 'import') {
    try {
      const privateKey = ctx.message.text.trim();
      
      // Delete the message containing the private key for security
      try {
        await ctx.deleteMessage();
      } catch (error) {
        console.log('Could not delete message:', error);
      }
      
      await commands.importWallet(ctx, privateKey, userState.walletNumber);
      commands.userStates.delete(userId);
    } catch (error) {
      console.error('Error processing private key:', error);
      await ctx.reply('Invalid private key format. Please try again.');
      commands.userStates.delete(userId);
    }
    return;
  }

  // Handle token address scanning
  const addressRegex = /(0x[a-fA-F0-9]{40})/;
  const match = ctx.message.text.match(addressRegex);
  
  if (match) {
    const address = match[0];
    let scanningMsg;

    try {
      scanningMsg = await ctx.reply('🔍 Scanning token...');
      
      // Try both chains
      let ethResult = await scanToken(address, 'eth');
      let bscResult = await scanToken(address, 'bsc');

      if (!ethResult.success && !bscResult.success) {
        await ctx.telegram.deleteMessage(ctx.chat.id, scanningMsg.message_id);
        return ctx.reply('⚠️ Token not found on ETH and BSC...');
      }

      const scanResult = ethResult.success ? ethResult : bscResult;
      const data = scanResult.data;
      const chainName = scanResult.chain.toUpperCase();
      const aiAudit = data.AIaudit;

      const formattedMessage = `
**🛡 Future Edge Analysis:**
├ Name: ${data.name} **(${data.symbol})**
├ Chain: ${chainName.toLowerCase()}
└ Renounced: ${data.owner === "0x0000000000000000000000000000000000000000" ? "✅" : "❌"}
CA: \`${address}\`

**🔘 Token Info:**
├ Supply: ${data.formattedTotalSupply || 'N/A'}
├ Top Holder: ${data.topHolder_perc || '0'}%
└ Contract Lock: ${data.clog_perc || '0'}%

**🤖 AI Contract Score:**
├ ${aiAudit?.executiveSummary?.Privileges || '⚪'} Privileges
└ ${aiAudit?.executiveSummary?.MaliciousCode || '⚪'} Malicious Code

**📄 CA Info:**
├ Initial Taxes: ${aiAudit?.executiveSummary?.TaxStructure?.["Initial Taxes"] || 'N/A'}
├ Final Taxes: ${aiAudit?.executiveSummary?.TaxStructure?.["Final Taxes"] || 'N/A'}
├ Reduced after: ${aiAudit?.executiveSummary?.TaxStructure?.["Reduced after"] || 'N/A'}
├ Transaction Limit: ${aiAudit?.executiveSummary?.TransactionLimit || 'N/A'}
└ Enforced For: ${aiAudit?.executiveSummary?.EnforcedFor || 'N/A'}

**⚠️ Findings:**
${formatFindings(aiAudit?.executiveSummary?.findings || [])}

*Generated by Future Edge Bot* 🤖
`;

      const chartUrl = getDexScreenerUrl(scanResult.chain.toLowerCase(), address);

      const buyButton = Markup.inlineKeyboard([
        [
          Markup.button.callback('🟩 Buy', 'buy'),
          Markup.button.url('📊 Chart', chartUrl)
        ]
      ]);

      await ctx.telegram.deleteMessage(ctx.chat.id, scanningMsg.message_id);
      
      await ctx.reply(formattedMessage, { 
        parse_mode: 'Markdown',
        disable_web_page_preview: true,
        ...buyButton
      });

    } catch (error) {
      console.error('Critical error in scanning process:', error);
      
      if (scanningMsg) {
        await ctx.telegram.deleteMessage(ctx.chat.id, scanningMsg.message_id)
          .catch(err => console.error('Error deleting scanning message:', err));
      }

      ctx.reply('❌ Error occurred while scanning. Please try again later.');
    }
  }
});

// Action Handlers
const setupBotActions = () => {
  // Navigation Actions
  bot.action('home', async (ctx) => {
    await ctx.answerCbQuery();
    await commands.startCommand(ctx);
  });

  bot.action('scanner', async (ctx) => {
    await ctx.answerCbQuery();
    await commands.scannerCommand(ctx);
  });

  bot.action('wallet', async (ctx) => {
    await ctx.answerCbQuery();
    await commands.walletCommand(ctx);
  });

  // Wallet Management Actions
  commands.setupWalletActions(bot);

  // Feature Actions
  bot.action('active', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('Active trades feature coming soon!');
  });

  bot.action('settings', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('Settings feature coming soon!');
  });

  bot.action('bridge', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('Bridge feature coming soon!');
  });

  bot.action('transfer', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('Transfer feature coming soon!');
  });

  bot.action('snipe', async (ctx) => {
    await ctx.answerCbQuery();
    await ctx.reply('Snipe feature coming soon!');
  });
};

// Setup all actions
setupBotActions();

// Error Handler
bot.catch((err, ctx) => {
  console.error('Bot error:', {
    error: err,
    updateType: ctx.updateType,
    userData: ctx.from,
    messageText: ctx.message?.text
  });

  if (err.code === 'ETIMEDOUT') {
    ctx.reply('⌛ Request timed out. Please try again.');
  } else if (err.response && err.response.status === 429) {
    ctx.reply('⚠️ Too many requests. Please try again later.');
  } else {
    ctx.reply('❌ An error occurred. Please try again later.');
  }
});

// Start bot
bot.launch()
  .then(() => {
    console.log('🤖 Future Edge Bot is running');
    console.log('✅ Token scanner is active on ETH and BSC chains');
    console.log('📡 Connected to EVA API');
  })
  .catch(err => {
    console.error('Bot failed to start:', err);
    process.exit(1);
  });

// Graceful shutdown
process.once('SIGINT', () => {
  console.log('Bot is shutting down...');
  bot.stop('SIGINT');
});

process.once('SIGTERM', () => {
  console.log('Bot is shutting down...');
  bot.stop('SIGTERM');
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection:', {
    reason: reason,
    promise: promise
  });
});

module.exports = bot;